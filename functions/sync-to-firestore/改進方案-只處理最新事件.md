# Edge Function 改進方案：只處理每個訂單的最新事件

## 問題分析

### 當前問題
1. Edge Function 可能處理了多個事件，包括舊事件
2. 舊事件的狀態可能覆蓋了新事件的狀態
3. 導致 Firestore 狀態從 `inProgress` 倒退回 `pending`

### 當前邏輯
```typescript
// 查詢未處理的事件（批次處理，每次最多 10 個）
const { data: events } = await supabase
  .from('outbox')
  .select('*')
  .is('processed_at', null)
  .lt('retry_count', 3)
  .order('created_at', { ascending: true })  // 按創建時間升序
  .limit(10)
```

**問題**：
- 如果有多個未處理事件，會按創建時間順序處理
- 但如果處理過程中又有新事件產生，可能導致順序混亂
- 並行處理（`Promise.allSettled`）可能導致舊事件後寫入 Firestore

## 改進方案 1：只處理每個訂單的最新事件

### 修改查詢邏輯

```typescript
// 查詢每個訂單的最新未處理事件
const { data: events } = await supabase
  .from('outbox')
  .select('*')
  .is('processed_at', null)
  .lt('retry_count', 3)
  .order('created_at', { ascending: false })  // ✅ 改為降序，優先處理最新事件
  .limit(10)
```

### 優點
- 優先處理最新事件
- 減少狀態倒退的風險

### 缺點
- 舊事件可能永遠不會被處理
- 需要定期清理舊事件

## 改進方案 2：使用 DISTINCT ON 只選擇每個訂單的最新事件

### SQL 查詢

```sql
-- 使用 DISTINCT ON 只選擇每個訂單的最新未處理事件
SELECT DISTINCT ON (aggregate_id) *
FROM outbox
WHERE processed_at IS NULL
  AND retry_count < 3
  AND aggregate_type = 'booking'
ORDER BY aggregate_id, created_at DESC
LIMIT 10;
```

### 在 Edge Function 中實現

```typescript
// 使用原生 SQL 查詢
const { data: events } = await supabase
  .rpc('get_latest_unprocessed_events', {
    event_limit: 10
  })
```

### 創建 RPC 函數

```sql
CREATE OR REPLACE FUNCTION get_latest_unprocessed_events(event_limit INT)
RETURNS SETOF outbox AS $$
BEGIN
  RETURN QUERY
  SELECT DISTINCT ON (aggregate_id) *
  FROM outbox
  WHERE processed_at IS NULL
    AND retry_count < 3
    AND aggregate_type = 'booking'
  ORDER BY aggregate_id, created_at DESC
  LIMIT event_limit;
END;
$$ LANGUAGE plpgsql;
```

### 優點
- 確保每個訂單只處理最新事件
- 避免狀態倒退
- 舊事件會被自動跳過

### 缺點
- 需要創建額外的 RPC 函數
- 舊事件需要定期清理

## 改進方案 3：在 Firestore 寫入前檢查時間戳

### 修改 upsertFirestoreDocument 函數

```typescript
async function upsertFirestoreDocument(bookingId: string, data: any, eventCreatedAt: string): Promise<void> {
  // 1. 先讀取 Firestore 中的現有文檔
  const existingDoc = await getFirestoreDocument(bookingId);
  
  // 2. 如果現有文檔存在，檢查時間戳
  if (existingDoc && existingDoc.updatedAt) {
    const existingTime = new Date(existingDoc.updatedAt);
    const newTime = new Date(eventCreatedAt);
    
    // 3. 如果新事件的時間早於現有文檔，跳過更新
    if (newTime < existingTime) {
      console.log(`⚠️  跳過舊事件: ${bookingId}, 事件時間: ${eventCreatedAt}, 現有時間: ${existingDoc.updatedAt}`);
      return;
    }
  }
  
  // 4. 繼續正常的更新流程
  // ...
}
```

### 優點
- 在 Firestore 層面防止狀態倒退
- 不需要修改查詢邏輯
- 最安全的方案

### 缺點
- 需要額外的 Firestore 讀取操作
- 增加延遲和成本

## 推薦方案：方案 2 + 方案 3 組合

### 實施步驟

1. **創建 RPC 函數**（方案 2）
   - 確保只查詢每個訂單的最新事件

2. **添加時間戳檢查**（方案 3）
   - 在 Firestore 寫入前檢查時間戳
   - 防止舊事件覆蓋新狀態

3. **定期清理舊事件**
   - 創建定時任務，清理已處理的舊事件
   - 或標記舊的未處理事件為已處理

### 實施代碼

#### 1. 創建 RPC 函數

```sql
-- 文件：supabase/migrations/20251015_create_get_latest_unprocessed_events.sql

CREATE OR REPLACE FUNCTION get_latest_unprocessed_events(event_limit INT DEFAULT 10)
RETURNS SETOF outbox AS $$
BEGIN
  RETURN QUERY
  SELECT DISTINCT ON (aggregate_id) *
  FROM outbox
  WHERE processed_at IS NULL
    AND retry_count < 3
    AND aggregate_type = 'booking'
  ORDER BY aggregate_id, created_at DESC
  LIMIT event_limit;
END;
$$ LANGUAGE plpgsql;

-- 測試函數
SELECT * FROM get_latest_unprocessed_events(10);
```

#### 2. 修改 Edge Function

```typescript
// 文件：supabase/functions/sync-to-firestore/index.ts

// 修改查詢邏輯
const { data: events, error: fetchError } = await supabase
  .rpc('get_latest_unprocessed_events', { event_limit: 10 })

if (fetchError) {
  throw new Error(`查詢 outbox 失敗: ${fetchError.message}`)
}
```

#### 3. 添加時間戳檢查（可選但推薦）

```typescript
// 在 syncBookingToFirestore 函數中添加
async function syncBookingToFirestore(event: OutboxEvent): Promise<void> {
  const bookingId = event.aggregate_id
  const bookingData = event.payload
  const eventCreatedAt = event.created_at  // ✅ 記錄事件創建時間
  
  // ... 構建 firestoreData
  
  // 添加事件創建時間到數據中
  const firestoreDataWithTimestamp = {
    ...firestoreData,
    lastSyncedAt: {
      _timestamp: eventCreatedAt  // ✅ 記錄同步時間
    }
  }
  
  // 更新 Firestore（帶時間戳檢查）
  if (event.event_type === 'deleted') {
    await deleteFirestoreDocument(bookingId)
  } else {
    await upsertFirestoreDocumentWithTimestampCheck(
      bookingId, 
      firestoreDataWithTimestamp,
      eventCreatedAt  // ✅ 傳遞事件時間
    )
  }
}
```

## 臨時修復方案

如果無法立即實施上述改進，可以使用以下臨時方案：

### 方案 A：手動清理舊事件

```sql
-- 標記所有舊的未處理事件為已處理
WITH latest_events AS (
  SELECT 
    aggregate_id,
    MAX(created_at) AS latest_created_at
  FROM outbox
  WHERE aggregate_type = 'booking'
  GROUP BY aggregate_id
)
UPDATE outbox o
SET 
  processed_at = NOW(),
  error_message = '手動標記為已處理（舊事件）'
FROM latest_events le
WHERE o.aggregate_id = le.aggregate_id
  AND o.created_at < le.latest_created_at
  AND o.processed_at IS NULL
  AND o.aggregate_type = 'booking';
```

### 方案 B：修改 Edge Function 查詢順序

```typescript
// 簡單修改：改為降序處理
const { data: events } = await supabase
  .from('outbox')
  .select('*')
  .is('processed_at', null)
  .lt('retry_count', 3)
  .order('created_at', { ascending: false })  // ✅ 改為降序
  .limit(10)
```

## 驗證步驟

1. **執行診斷腳本**
   ```bash
   # 在 Supabase SQL Editor 中執行
   supabase/診斷-Firestore狀態異常跳轉.sql
   ```

2. **檢查是否有重複 Trigger**
   ```bash
   # 在 Supabase SQL Editor 中執行
   supabase/檢查並修復重複Trigger.sql
   ```

3. **實施改進方案**
   - 創建 RPC 函數
   - 修改 Edge Function
   - 重新部署

4. **測試驗證**
   - 創建新訂單
   - 測試狀態變更
   - 確認 Firestore 狀態不會倒退

---

**文檔版本**: 1.0  
**最後更新**: 2025-10-15

